# Java相关

## Java 基础

### 静态方法为什么不能调用非静态成员?

1. 静态方法是属于类的，在类加载的时候就会分配内存，可以通过类名直接访问。而非静态成员属于实例对象，只有在对象实例化之后才存在，需要通过类的实例对象去访问。
2. 在类的非静态成员不存在的时候静态成员就已经存在了，此时调用在内存中还不存在的非静态成员，属于非法操作。
3. 调用静态方法无需创建对象，静态方法在访问本类的成员时，只允许访问静态成员（即静态成员变量和静态方法），不允许访问实例成员（即实例成员变量和实例方法），而实例方法不存在这个限制。

### 重载和重写的区别

**重载**就是同样的一个方法能够根据输入数据的不同，做出不同的处理

**重写**就是当子类继承自父类的相同方法，输入数据一样，但要做出有别于父类的响应时，你就要覆盖父类方法

### 基本数据类型

Java 中有 8 种基本数据类型，分别为：

- 6 种数字类型：
  - 4 种整数型：`byte`、`short`、`int`、`long`
  - 2 种浮点型：`float`、`double`
- 1 种字符类型：`char`
- 1 种布尔型：`boolean`

### 基本类型和包装类型的区别

- 包装类型不赋值就是 `null` ，而基本类型有默认值且不是 `null`。
- 包装类型可用于泛型，而基本类型不可以。
- 基本数据类型的局部变量存放在 Java 虚拟机栈中的局部变量表中，基本数据类型的成员变量（未被 `static` 修饰 ）存放在 Java 虚拟机的堆中。包装类型属于对象类型，我们知道几乎所有对象实例都存在于堆中。
- 相比于对象类型， 基本数据类型占用的空间非常小。

**为什么说是几乎所有对象实例呢？** 这是因为 HotSpot 虚拟机引入了 JIT 优化之后，会对对象进行逃逸分析，如果发现某一个对象并没有逃逸到方法外部，那么就可能通过标量替换来实现栈上分配，而避免堆上分配内存

### 包装类型的缓存机制

Java 基本数据类型的包装类型的大部分都用到了缓存机制来提升性能。`Byte`,`Short`,`Integer`,`Long` 这 4 种包装类默认创建了数值 **[-128，127]** 的相应类型的缓存数据，`Character` 创建了数值在 **[0,127]** 范围的缓存数据，`Boolean` 直接返回 `True` or `False`。

**所有整型包装类对象之间值的比较，全部使用 equals 方法比较**。

```java
Integer i1 = 40;
Integer i2 = new Integer(40);
System.out.println(i1==i2); // false
```

`i1` 直接使用的是缓存中的对象，而`Integer i2 = new Integer(40)` 会直接创建新的对象，== 比较的是地址，所以为 false。

### 接口和抽象类的共同点和区别

**共同点** ：

- 都不能被实例化。
- 都可以包含抽象方法。
- 都可以有默认实现的方法（Java 8 可以用 `default` 关键在接口中定义默认方法）。

**区别** ：

- 接口主要用于对类的行为进行约束，你实现了某个接口就具有了对应的行为。抽象类主要用于代码复用，强调的是所属关系（比如说我们抽象了一个发送短信的抽象类）。
- 接口可以继承多个父类，抽象类只能继承一个父类。
- 接口中的成员变量只能是 `public static final` 类型的，不能被修改且必须有初始值，而抽象类的成员变量默认 default，可在子类中被重新定义，也可被重新赋值。
- 接口侧重于实现封装（接口隐藏内部实现），抽象类侧重于提取共性。

### 深拷贝和浅拷贝的区别

- **浅拷贝**：浅拷贝会在堆上创建一个新的对象（区别于引用拷贝的一点），不过，如果原对象内部的属性是引用类型的话，浅拷贝会直接复制内部对象的引用地址，也就是说拷贝对象和原对象共用同一个内部对象，B 复制 A，改变B，A也跟着改变。浅拷贝只复制某个对象的引用，而不复制对象本身，新旧对象还是共享同一块内存。
- **深拷贝** ：深拷贝会完全复制整个对象，包括这个对象所包含的内部对象，B 复制 A，改变B，A不会跟着改变。深拷贝会创造一个一摸一样的对象，新对象和原对象不共享内存，修改新对象不会改变原对对象。

### == 和 equals( ) 的区别

**`==`** 对于基本类型和引用类型的作用效果是不同的：

- 对于基本数据类型来说，`==` 比较的是值。
- 对于引用数据类型来说，`==` 比较的是对象的内存地址。

**`equals()`** 不能用于判断基本数据类型的变量，只能用来判断两个对象是否相等，如果没有对 equals 方法进行重写，则相当于 ==，比较的是引用类型的变量**所指向的对象的地址值**。

* 一般情况下，类会重写 equals 方法用来比较两个对象的内容是否相等。比如 String 类中的 equals() 是被重写了，比较的是**对象的值**。

### String、StringBuffer 和 StringBuilder

**可变性**

`String` 是不可变的。

原因：

1. 保存字符串的数组被 `final` 修饰且为私有的，并且`String` 类没有提供/暴露修改这个字符串的方法。
2. `String` 类被 `final` 修饰导致其不能被继承，进而避免了子类破坏 `String` 不可变。

`StringBuilder` 与 `StringBuffer` 都继承自 `AbstractStringBuilder` 类，在 `AbstractStringBuilder` 中也是使用字符数组保存字符串，不过没有使用 `final` 和 `private` 关键字修饰，最关键的是这个 `AbstractStringBuilder` 类还提供了很多修改字符串的方法比如 `append` 方法。

**线程安全性**

`String` 中的对象是不可变的，也就可以理解为常量，线程安全。`AbstractStringBuilder` 是 `StringBuilder` 与 `StringBuffer` 的公共父类，定义了一些字符串的基本操作，如 `expandCapacity`、`append`、`insert`、`indexOf` 等公共方法。`StringBuffer` 对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。`StringBuilder` 并没有对方法进行加同步锁，所以是非线程安全的。

**性能**

每次对 `String` 类型进行改变的时候，都会生成一个新的 `String` 对象，然后将指针指向新的 `String` 对象。`StringBuffer` 每次都会对 `StringBuffer` 对象本身进行操作，而不是生成新的对象并改变对象引用。相同情况下使用 `StringBuilder` 相比使用 `StringBuffer` 仅能获得 10%~15% 左右的性能提升，但却要冒多线程不安全的风险。

## 容器

###  List, Set, Queue, Map 四者的区别

- `List`(对付顺序的好帮手): 存储的元素是有序的、可重复的。
- `Set`(注重独一无二的性质): 存储的元素是无序的、不可重复的。
- `Queue`(实现排队功能的叫号机): 按特定的排队规则来确定先后顺序，存储的元素是有序的、可重复的。
- `Map`(用 key 来搜索的专家): 使用键值对（key-value）存储，类似于数学上的函数 y=f(x)，"x" 代表 key，"y" 代表 value，key 是无序的、不可重复的，value 是无序的、可重复的，每个键最多映射到一个值。

### HashMap 和 Hashtable 的区别

* **线程是否安全：** `HashMap` 是非线程安全的，`Hashtable` 是线程安全的，因为 `Hashtable` 内部的方法基本都经过`synchronized` 修饰。（如果你要保证线程安全的话就使用 `ConcurrentHashMap` 吧！）；
* **效率：** 因为线程安全的问题，`HashMap` 要比 `Hashtable` 效率高一点。另外，`Hashtable` 基本被淘汰，不要在代码中使用它；
* **对 Null key 和 Null value 的支持：** `HashMap` 可以存储 null 的 key 和 value，但 null 作为键只能有一个，null 作为值可以有多个；Hashtable 不允许有 null 键和 null 值，否则会抛出 `NullPointerException`；
* **初始容量大小和每次扩充容量大小的不同 ：** ① 创建时如果不指定容量初始值，`Hashtable` 默认的初始大小为 11，之后每次扩充，容量变为原来的 2n+1。`HashMap` 默认的初始化大小为 16。之后每次扩充，容量变为原来的 2 倍。② 创建时如果给定了容量初始值，那么 Hashtable 会直接使用你给定的大小，而 `HashMap` 会将其扩充为 2 的幂次方大小（`HashMap` 中的`tableSizeFor()`方法保证，下面给出了源代码）。也就是说 `HashMap` 总是使用 2 的幂作为哈希表的大小，后面会介绍到为什么是 2 的幂次方；
* **底层数据结构：** JDK1.8 以后的 `HashMap` 在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树）时，将链表转化为红黑树，以减少搜索时间。Hashtable 没有这样的机制。

### HashSet 如何检查重复

当你把对象加入`HashSet`时，`HashSet` 会先计算对象的`hashcode`值来判断对象加入的位置，同时也会与其他加入的对象的 `hashcode` 值作比较，如果没有相符的 `hashcode`，`HashSet` 会假设对象没有重复出现。但是如果发现有相同 `hashcode` 值的对象，这时会调用`equals()`方法来检查 `hashcode` 相等的对象是否真的相同。如果两者相同，`HashSet` 就不会让加入操作成功。

### HashMap

* JDK 1.8 之前，HashMap 底层是数组和链表结合，JDK 1.8 之后变为数组和链表以及红黑树结合。
* HashMap 通过 key 的 hashCode 经过**扰动函数**（二次哈希，为了综合高位数据，让哈希分布更为均匀）处理过后得到 hash 值，然后通过 `(n - 1) & hash` 即 hash % n 来判断当前元素存放的位置（这里的 n 指的是数组的长度），如果当前位置存在元素的话，就判断该元素与要存入的元素的 hash 值以及 key 是否相同，如果相同的话，直接覆盖，不相同就通过拉链法解决冲突（JDK 1.7 之前）。
* JDK 1.8 之后，当链表长度大于阈值（默认为 8）时，会首先调用 `treeifyBin()`方法。这个方法会根据 HashMap 数组来决定是否转换为红黑树。只有当数组长度大于或者等于 64 的情况下，才会执行转换红黑树操作，以减少搜索时间。否则，就是只是执行 `resize()` 方法对数组扩容。
* 链表 -> 红黑树，先判断数组长度是否大于或者等于 64，不是则先进行扩容，是则再判断链表长度是否大于阈值（默认为 8），若大于则树化。
* 扩容：当链表总长度大于数组长度 * 加载因子，则选择扩容。
* **变为红黑树的链表阈值为何默认是8？**因为红黑树是用来避免 Dos 攻击，是极端的情况，一般不会转变，在负载因子0.75 的情况下。长度超过 8 的链表几率很小，所以选择 8 是为了让树化的几率变小。
* **数组容量为何是 2 的 n 次幂？**取模时可以用位运算`(n - 1) & hash` 代替 hash % n，效率更高；扩容时计算新的位置效率也更高，追求性能
* **加载因子为何默认是 0.75f？**在空间占用和查询时间之间取得较好的权衡
* 1.7 put 为头插法，在扩容过程中会发生**死链**（并发下的 Rehash 会造成元素之间会形成一个循环链表）问题，大于等于阈值且没有空位才扩容 1.8 put 为尾插法，大于阈值就扩容

## 并发编程

### 线程和进程

* 进程是程序的一次执行过程，是系统运行程序的基本单位，因此进程是动态的。系统运行一个程序即是一个进程从创建，运行到消亡的过程，是系统进行**资源分配的基本单位**。
* 线程是属于进程的，是一个基本的 CPU 执行单元，是程序执行流的最小单元。线程是进程中的一个实体，是系统**独立调度的基本单位**，线程本身不拥有系统资源，只拥有一点在运行中必不可少的资源，但它可与同属一个进程的其他线程共享进程所拥有的全部资源。
* 关系：
  * 一个进程中可以有多个线程，多个线程共享进程的**堆**和**方法区**，每个线程有自己的**程序计数器**、**虚拟机栈** 和 **本地方法栈**。
  * 线程执行开销小，但不利于资源的管理和保护；进程执行开销大，但有利于资源的管理和保护。

### 进程间的通信方式

* 同一台计算机的进程通信称为 IPC（Inter-process communication）
  * 信号量：信号量是一个计数器，用于多进程对共享数据的访问，解决同步相关的问题并避免竞争条件
  * 共享存储：多个进程可以访问同一块内存空间，需要使用信号量用来同步对共享存储的访问
  * 管道通信：管道是用于连接一个读进程和一个写进程以实现它们之间通信的一个共享文件 pipe 文件，该文件同一时间只允许一个进程访问，所以只支持**半双工通信**
    * 匿名管道（Pipes）：用于具有亲缘关系的父子进程间或者兄弟进程之间的通信
    * 命名管道（Names Pipes）：以磁盘文件的方式存在，可以实现本机任意两个进程通信，遵循 FIFO
  * 消息队列：内核中存储消息的链表，由消息队列标识符标识，能在不同进程之间提供**全双工通信**，对比管道：
    * 匿名管道存在于内存中的文件；命名管道存在于实际的磁盘介质或者文件系统；消息队列存放在内核中，只有在内核重启（操作系统重启）或者显示地删除一个消息队列时，该消息队列才被真正删除
    * 读进程可以根据消息类型有选择地接收消息，而不像 FIFO 那样只能默认地接收

* 不同计算机之间的进程通信，需要通过网络，并遵守共同的协议，例如 HTTP
  * 套接字：与其它通信机制不同的是，可用于不同机器间的互相通信

### 线程间的通信方式

线程同步是两个或多个共享关键资源的线程的并发执行。应该同步线程以避免关键的资源使用冲突。操作系统一般有下面三种线程同步的方式：

1. **互斥量(Mutex)**：采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限。因为互斥对象只有一个，所以可以保证公共资源不会被多个线程同时访问。比如 Java 中的 synchronized 关键词和各种 Lock 都是这种机制。
2. **信号量(Semaphore)** ：它允许同一时刻多个线程访问同一资源，但是需要控制同一时刻访问此资源的最大线程数量。
3. **事件(Event)** ：Wait/Notify：通过通知操作的方式来保持多线程同步，还可以方便的实现多线程优先级的比较操作。

### 并发和并行

* **并发**：两个及两个以上的作业在同一 **时间段** 内执行，交替执行
* **并行**：两个及两个以上的作业在同一 **时刻** 执行，同时执行

### 创建线程的三种方式

* 利用 Thread 类创建一个对象

  ```java
  Thread t = new Thread();
  t.start();
  ```

  * 优点：编码简单
  * 缺点：线程类已经继承了 Thread 类无法继承其他类了，功能不能通过继承拓展（单继承的局限性）

* 利用 Runnable 类创建一个对象

  ```java
  // 匿名内部类
  Runnable runnable = new Runnable() {
  	@Override
  	public void run() {
  		System.out.println("t1线程在运行");
  	}
  Thread t1 = new Thread(runnable, "t1");
  t1.start();
  // Lambda 表达式
  Runnable runnable = () -> System.out.println("t1线程在运行");
  Thread t1 = new Thread(runnable, "t1");
  t1.start();
  ```

  * 缺点：代码复杂一点。
  * 优点：

    1. 线程任务类只是实现了 Runnable 接口，可以继续继承其他类，避免了单继承的局限性
    2. 同一个线程任务对象可以被包装成多个线程对象
    3. 适合多个线程去共享同一个资源
    4. 实现解耦操作，线程任务代码可以被多个线程共享，线程任务代码和线程独立
    5. 线程池可以放入实现 Runnable 或 Callable 线程任务对象

* 实现 Callable 接口

  ```java
  Callable<String> integerCallable = () -> Thread.currentThread().getName();
  FutureTask<String> task = new FutureTask<>(integerCallable);
  Thread thread = new Thread(task);
  thread.start();
  try {
      String s = task.get();
      System.out.println(s);
  } catch (InterruptedException | ExecutionException e) {
      throw new RuntimeException(e);
  }
  ```

* 实现 Runnable 接口和 Callable 接口的区别

  **`Runnable` 接口** 不会返回结果或抛出检查异常，但是 **`Callable` 接口** 可以。所以，如果任务不需要返回结果或抛出异常推荐使用 **`Runnable` 接口** ，这样代码看起来会更加简洁。

### 线程的状态和生命周期

线程由生到死的完整过程（生命周期）：当线程被创建并启动以后，既不是一启动就进入了执行状态，也不是一直处于执行状态，在 API 中 `java.lang.Thread.State` 这个枚举中给出了六种线程状态：

| 线程状态                   | 导致状态发生条件                                             |
| -------------------------- | ------------------------------------------------------------ |
| NEW（新建）                | 线程刚被创建，但是并未启动，还没调用 start 方法，只有线程对象，没有线程特征 |
| Runnable（可运行）         | 线程可以在 Java 虚拟机中运行的状态，可能正在运行自己代码，也可能没有，这取决于操作系统处理器，调用了 t.start() 方法：就绪（经典叫法） |
| Blocked（锁阻塞）          | 当一个线程试图获取一个对象锁，而该对象锁被其他的线程持有，则该线程进入 Blocked 状态；当该线程持有锁时，该线程将变成 Runnable 状态 |
| Waiting（无限等待）        | 一个线程在等待另一个线程执行一个（唤醒）动作时，该线程进入 Waiting 状态，进入这个状态后不能自动唤醒，必须等待另一个线程调用 notify 或者 notifyAll 方法才能唤醒 |
| Timed Waiting （计时等待） | 有几个方法有超时参数，调用将进入 Timed Waiting 状态，这一状态将一直保持到超时期满或者接收到唤醒通知。带有超时参数的常用方法有 Thread.sleep 、Object.wait |
| Teminated（被终止）        | run 方法正常退出而死亡，或者因为没有捕获的异常终止了 run 方法而死亡 |

* NEW → RUNNABLE：当调用 t.start() 方法时，由 NEW → RUNNABLE

* RUNNABLE ←→ WAITING：

  * 调用 obj.wait() 方法时

    调用 obj.notify()、obj.notifyAll()、t.interrupt()：

    * 竞争锁成功，t 线程从 WAITING → RUNNABLE
    * 竞争锁失败，t 线程从 WAITING → BLOCKED

  * 当前线程调用 t.join() 方法，注意是当前线程在 t 线程对象的监视器上等待

  * 当前线程调用 LockSupport.park() 方法

* RUNNABLE ←→ TIMED_WAITING：调用 obj.wait(long n) 方法、当前线程调用 t.join(long n) 方法、当前线程调用 Thread.sleep(long n)

* RUNNABLE ←→ BLOCKED：t 线程用 synchronized(obj) 获取了对象锁时竞争失败

### 上下文切换

线程在执行过程中会有自己的运行条件和状态（也称上下文），出现如下情况的时候，线程会从占用 CPU 状态中退出。

- 主动让出 CPU，比如调用了 `sleep()`, `wait()` 等。
- 时间片用完，因为操作系统要防止一个线程或者进程长时间占用CPU导致其他线程或者进程饿死。
- 调用了阻塞类型的系统中断，比如请求 IO，线程被阻塞。
- 被终止或结束运行

这其中前三种都会发生线程切换，线程切换意味着需要保存当前线程的上下文，留待线程下次占用 CPU 的时候恢复现场。并加载下一个将要占用 CPU 的线程上下文。这就是所谓的 **上下文切换**。

### 死锁以及避免死锁

线程死锁描述的是这样一种情况：多个线程同时被阻塞，它们中的一个或者全部都在等待某个资源被释放。由于线程被无限期地阻塞，因此程序不可能正常终止。比如线程 A 持有资源 2，线程 B 持有资源 1，他们同时都想申请对方的资源，所以这两个线程就会互相等待而进入死锁状态。

Java 死锁产生的四个必要条件：

1. 互斥条件，即当资源被一个线程使用（占有）时，别的线程不能使用
2. 不可剥夺条件，资源请求者不能强制从资源占有者手中夺取资源，资源只能由资源占有者主动释放
3. 请求和保持条件，即当资源请求者在请求其他的资源的同时保持对原有资源的占有
4. 循环等待条件，即存在一个等待循环队列：p1 要 p2 的资源，p2 要 p1 的资源，形成了一个等待环路

四个条件都成立的时候，便形成死锁。死锁情况下打破上述任何一个条件，便可让死锁消失，避免死锁要注意加锁顺序

### sleep() 和 wait() 方法区别和共同点

共同点：

* 都是让线程暂时放弃 CPU 的使用权，进入阻塞状态

区别：

* sleep 是 Thread 的静态方法，wait 是 Object 的成员方法，每个对象都有
* `wait()` 方法被调用后，线程不会自动苏醒，需要别的线程调用同一个对象上的 `notify() `或者 `notifyAll()` 方法。`sleep() `方法执行完成后，线程会自动苏醒
* wait 方法的调用必须先获取wait对象的锁，而 sleep 则无此限制。`sleep()` 方法并不会释放对象的锁，而 `wait()` 方法执行后会释放对象锁 

### run 和 start 方法

new 一个 Thread，线程进入了新建状态。调用 `start()`方法，会启动一个线程并使线程进入了就绪状态，当分配到时间片后就可以开始运行了。 `start()` 会执行线程的相应准备工作，然后自动执行 `run()` 方法的内容，这是真正的多线程工作。 但是，直接执行 `run()` 方法，会把 `run()` 方法当成一个 main 线程下的普通方法去执行，并不会在某个线程中执行它，所以这并不是多线程工作。

总结： 调用 `start()` 方法方可启动线程并使线程进入就绪状态，直接执行 `run()` 方法的话不会以多线程的方式执行。

### 悲观锁

顾名思义，悲观锁是基于一种悲观的态度类来防止一切数据冲突，它是以一种预防的姿态在修改数据之前把数据锁住，然后再对数据进行读写，在它释放锁之前任何人都不能对其数据进行操作，直到前面一个人把锁释放后下一个人数据加锁才可对数据进行加锁，然后才可以对数据进行操作。

#### synchronized

##### synchronized 关键字使用的方法

* **修饰实例方法:** 作用于当前对象实例加锁，进入同步代码前要获得 **当前对象实例的锁**
* **修饰静态方法:** 也就是给当前类加锁，会作用于类的所有对象实例 ，进入同步代码前要获得 **当前 class 的锁**。因为静态成员不属于任何一个实例对象，是类成员（ *static 表明这是该类的一个静态资源，不管 new 了多少个对象，只有一份*）。所以，如果一个线程 A 调用一个实例对象的非静态 `synchronized` 方法，而线程 B 需要调用这个实例对象所属类的静态 `synchronized` 方法，是允许的，不会发生互斥现象，**因为访问静态 `synchronized` 方法占用的锁是当前类的锁，而访问非静态 `synchronized` 方法占用的锁是当前实例对象锁**。
* **修饰代码块** ：指定加锁对象，对给定对象/类加锁。`synchronized(this|object)` 表示进入同步代码库前要获得**给定对象的锁**。`synchronized(类.class)` 表示进入同步代码前要获得 **当前 class 的锁**

##### synchronized关键字修饰非静态方法和修饰静态方法有什么区别？

- synchronized修饰非静态方法，实际上是对调用该方法的对象加锁，俗称“对象锁”。
- synchronized修饰静态方法，实际上是对该类对象加锁，俗称“类锁”。

##### synchronized 关键字的底层原理

* Monitor 被翻译为监视器或管程，每个 Java 对象都可以关联一个 Monitor 对象，Monitor 也是 class，其**实例存储在堆中**，如果使用 synchronized 给对象上锁（重量级）之后，该对象头的 Mark Word 中就被设置指向 Monitor 对象的指针，这就是重量级锁。
* 工作流程
  * 开始时 Monitor 中 Owner 为 null
  * 当 Thread-2 执行 synchronized(obj) 就会将 Monitor 的所有者 Owner 置为 Thread-2，Monitor 中只能有一个 Owner，**obj 对象的 Mark Word 指向 Monitor**，把**对象原有的 MarkWord 存入线程栈中的锁记录**中（轻量级锁部分详解）
  * 在 Thread-2 上锁的过程，Thread-3、Thread-4、Thread-5 也执行 synchronized(obj)，就会进入 EntryList BLOCKED（双向链表：阻塞对列，非公平的）
  * Thread-2 执行完同步代码块的内容，根据 obj 对象头中 Monitor 地址寻找，设置 Owner 为空，把线程栈的锁记录中的对象头的值设置回 MarkWord
  * 唤醒 EntryList 中等待的线程来竞争锁，竞争是**非公平的**，如果这时有新的线程想要获取锁，可能直接就抢占到了，阻塞队列的线程就会继续阻塞
  * WaitSet 中的 Thread-0，是以前获得过锁，但条件不满足进入 WAITING 状态的线程（wait-notify 机制）

##### synchronized 锁升级

* **synchronized 是可重入、不公平的重量级锁**，所以可以对其进行优化，无锁 -> 偏向锁 -> 轻量级锁 -> 重量级锁，随着竞争的增加，只能锁升级，不能降级
* 偏向锁的思想是偏向于让第一个获取锁对象的线程，这个线程之后重新获取该锁不再需要同步操作
* 一个对象有多个线程要加锁，但加锁的时间是错开的（没有竞争），可以使用轻量级锁来优化，轻量级锁对使用者是透明的（不可见）**可重入锁**：线程可以进入任何一个它已经拥有的锁所同步着的代码块，可重入锁最大的作用是**避免死锁**
* 在尝试加轻量级锁的过程中，CAS 操作无法成功，可能是其它线程为此对象加上了轻量级锁（有竞争），这时需要进行锁膨胀，将轻量级锁变为**重量级锁**
* **自旋锁**：重量级锁竞争时，尝试获取锁的线程不会立即阻塞，可以使用**自旋**（默认 10 次）来进行优化，采用循环的方式去尝试获取锁

#### Lock

##### synchronized 和 ReentrantLock 的区别

* 锁的实现：synchronized 是 JVM 实现的，而 ReentrantLock 是 JDK 实现的
* 性能：新版本 Java 对 synchronized 进行了很多优化，synchronized 与 ReentrantLock 大致相同
* 使用：ReentrantLock 需要手动解锁，synchronized 执行完代码块自动解锁
* 可中断：ReentrantLock 可中断，而 synchronized 不行
* 公平锁：公平锁是指多个线程在等待同一个锁时，必须按照申请锁的时间顺序来依次获得锁
  * ReentrantLock 可以设置公平锁，synchronized 中的锁是非公平的
  * 不公平锁的含义是阻塞队列内公平，队列外非公平
* 锁超时：尝试获取锁，超时获取不到直接放弃，不进入阻塞队列
  * ReentrantLock 可以设置超时时间，synchronized 会一直等待
* 锁绑定多个条件：一个 ReentrantLock 可以同时绑定多个 Condition 对象，即条件变量
* 两者都是可重入锁

#### volatile

* Java 内存模型抽象了线程和主内存之间的关系，当前的 Java 内存模型下，线程可以把变量保存**本地内存**（比如机器的寄存器）中，而不是直接在主存中进行读写。这就可能造成一个线程在主存中修改了一个变量的值，而另外一个线程还继续使用它在寄存器中的变量值的拷贝，造成**数据的不一致**。要解决这个问题，就需要把变量声明为 **`volatile`** ，这就指示 JVM，这个变量是共享且不稳定的，每次使用它都到主存中进行读取。

* volatile 是 Java 虚拟机提供的**轻量级**的同步机制（三大特性）

  - **保证可见性**
  - **不保证原子性**
  - **保证有序性**（禁止指令重排）

* 并发编程的三个重要特性

  * **原子性** : 一次操作或者多次操作，要么所有的操作全部都得到执行并且不会受到任何因素的干扰而中断，要么都不执行。`synchronized` 可以保证代码片段的原子性。

  * **可见性** ：当一个线程对共享变量进行了修改，那么另外的线程都是立即可以看到修改后的最新值。`volatile` 关键字可以保证共享变量的可见性。

  * **有序性** ：代码在执行的过程中的先后顺序，Java 在编译器以及运行期间的优化，代码的执行顺序未必就是编写代码时候的顺序。`volatile` 关键字可以禁止指令进行重排序优化。

### 乐观锁

对于并发操作产生的线程安全问题持乐观态度，认为自己在使用数据时不会有别的线程修改数据，所以不会添加锁，只是在更新数据的时候去判断之前有没有别的线程更新了这个数据，如果这个数据没有被更新，当前线程将自己修改的数据成功写入。如果数据已经被其他线程更新，则执行其他操作，如报错或自动重试。

#### cas

* Compare-And-Set 比较并交换，对比版本号，如果修改了版本号就变了交换，版本号一样就交换；比较当前工作内存中的值和主物理内存中的值，如果相同则执行规定操作，否则继续比较直到主内存和工作内存的值一致为止
* CAS 特点：

  * CAS 体现的是**无锁并发、无阻塞并发**，线程不会陷入阻塞，线程不需要频繁切换状态（上下文切换，系统调用）
  * CAS 是基于乐观锁的思想
* CAS 缺点：

  - 循环时间长，开销大，因为执行的是循环操作，如果比较不成功一直在循环，最差的情况某个线程一直取到的值和预期值都不一样，就会无限循环导致饥饿，**使用 CAS 线程数不要超过 CPU 的核心数**
  - 只能保证一个共享变量的原子操作
    - 对于一个共享变量执行操作时，可以通过循环 CAS 的方式来保证原子操作
    - 对于多个共享变量操作时，循环 CAS 就无法保证操作的原子性，这个时候**只能用锁来保证原子性**
  - ABA 问题：当进行获取主内存值时，该内存值在写入主内存时已经被修改了 N 次，但是最终又改成原来的值，其他线程先把 A 改成 B 又改回 A，主线程**仅能判断出共享变量的值与最初值 A 是否相同**，不能感知到这种从 A 改为 B 又 改回 A 的情况，这时 CAS 虽然成功，但是过程存在问题

### ThreadLocal

* `ThreadLocal`类主要解决的就是让每个线程绑定自己的值，可以将`ThreadLocal`类形象的比喻成存放数据的盒子，盒子中可以存储每个线程的私有数据，可以使用 `get（）` 和 `set（）` 方法来获取默认值或将其值更改为当前线程所存的副本的值，从而避免了线程安全问题。
* 底层原理
  * JDK8 以前：每个 ThreadLocal 都创建一个 Map，然后用线程作为 Map 的 key，要存储的局部变量作为 Map 的 value，达到各个线程的局部变量隔离的效果。这种结构会造成 Map 结构过大和内存泄露，因为 Thread 停止后无法通过 key 删除对应的数据
  * JDK8 以后：每个 Thread 维护一个 ThreadLocalMap，这个 Map 的 key 是 ThreadLocal 实例本身，value 是真正要存储的值
* ThreadLocal 内存泄漏问题：`ThreadLocalMap` 中使用的 key 为 `ThreadLocal` 的弱引用，而 value 是强引用。所以，如果 `ThreadLocal` 没有被外部强引用的情况下，在垃圾回收的时候，key 会被清理掉，而 value 不会被清理掉。这样一来，`ThreadLocalMap` 中就会出现 key 为 null 的 Entry。假如我们不做任何措施的话，value 永远无法被 GC 回收，这个时候就可能会产生内存泄露。ThreadLocalMap 实现中已经考虑了这种情况，在调用 `set()`、`get()`、`remove()` 方法的时候，会清理掉 key 为 null 的记录。使用完 `ThreadLocal`方法后 最好手动调用`remove()`方法
* 项目中的 UserHolder 类用到了 ThreadLocal 

### 线程池

**线程池**提供了一种限制和管理资源（包括执行一个任务）的方式。 每个**线程池**还维护一些基本统计信息，例如已完成任务的数量。

* **线程池的好处**：

  - **降低资源消耗**。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。
  - **提高响应速度**。当任务到达时，任务可以不需要等到线程创建就能立即执行。
  - **提高线程的可管理性**。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。

* 线程池创建方式

  * 通过构造方法 ThreadPoolExecutor 构造
  * 通过 Executor 框架的工具类 Executors 来实现
    * **FixedThreadPool** ： 该方法返回一个固定线程数量的线程池。该线程池中的线程数量始终不变。当有一个新的任务提交时，线程池中若有空闲线程，则立即执行。若没有，则新的任务会被暂存在一个任务队列中，待有线程空闲时，便处理在任务队列中的任务。
    * **SingleThreadExecutor：** 方法返回一个只有一个线程的线程池。若多余一个任务被提交到该线程池，任务会被保存在一个任务队列中，待线程空闲，按先入先出的顺序执行队列中的任务。
    * **CachedThreadPool：** 该方法返回一个可根据实际情况调整线程数量的线程池。线程池的线程数量不确定，但若有空闲线程可以复用，则会优先使用可复用的线程。若所有线程均在工作，又有新的任务提交，则会创建新的线程处理任务。所有线程在当前任务执行完毕后，将返回线程池进行复用。

* **ThreadPoolExecutor 类的参数分析**

  * **`corePoolSize` :** 核心线程数定义了最小可以同时运行的线程数量。
  * **`maximumPoolSize` :** 当队列中存放的任务达到队列容量的时候，当前可以同时运行的线程数量变为最大线程数。
  * **`workQueue`:** 当新任务来的时候会先判断当前运行的线程数量是否达到核心线程数，如果达到的话，新任务就会被存放在队列中。
  * **`keepAliveTime`**：当线程池中的线程数量大于 `corePoolSize` 的时候，如果这时没有新的任务提交，核心线程外的线程不会立即销毁，而是会等待，直到等待的时间超过了 `keepAliveTime`才会被回收销毁；
  * **`unit`** ：`keepAliveTime` 参数的时间单位。
  * **`threadFactory`** ：线程工厂，创建新线程时用到，可以为线程创建时起名字
  * **`handler`** ：拒绝策略：如果当前同时运行的线程数量达到最大线程数量并且队列也已经被放满了任务时的策略
    * AbortPolicy：让调用者抛出 RejectedExecutionException 异常，**默认策略**
    * CallerRunsPolicy：让调用者运行的调节机制，将某些任务回退到调用者，从而降低新任务的流量
    * DiscardPolicy：直接丢弃任务，不予任何处理也不抛出异常
    * DiscardOldestPolicy：放弃队列中最早的任务，把当前任务加入队列中尝试再次提交当前任务

* 原理

  ![图解线程池实现原理](https://javaguide.cn/assets/%E5%9B%BE%E8%A7%A3%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86.2b9eb21a.png)

* 项目中 异步下单优惠券时用到过 SingleThreadExecutor

### AQS

AbstractQueuedSynchronizer，是阻塞式锁和相关的同步器工具的框架，许多同步类实现都依赖于该同步器

* **原理**：

  * 如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并将共享资源设置锁定状态
  * 请求的共享资源被占用，AQS 用 CLH 队列实现线程阻塞等待以及被唤醒时锁分配的机制，将暂时获取不到锁的线程加入到队列中
  * CLH 是一种基于双向链表的**高性能、公平的自旋锁**，AQS 是将每条请求共享资源的线程封装成一个 CLH 锁队列的一个结点（Node）来实现锁的分配
  * AQS 使用一个 int 成员变量 state 来表示同步状态，通过内置的 FIFO 队列来完成获取资源线程的排队工作。AQS 使用 CAS 对该同步状态进行原子操作实现对其值的修改。

* AQS 定义两种资源共享方式

  * **Exclusive**（独占）

    只有一个线程能执行，如 `ReentrantLock`。又可分为公平锁和非公平锁，`ReentrantLock` 同时支持两种锁，下面以 `ReentrantLock` 对这两种锁的定义做介绍：

    - **公平锁** ：按照线程在队列中的排队顺序，先到者先拿到锁
    - **非公平锁** ：当线程要获取锁时，先通过两次 CAS 操作去抢锁，如果没抢到，当前线程再加入到队列中等待唤醒。

  * **Share**（共享）

    多个线程可同时执行，如 `Semaphore/CountDownLatch`。

#### AQS 组件

- **`Semaphore`(信号量)-允许多个线程同时访问：** `synchronized` 和 `ReentrantLock` 都是一次只允许一个线程访问某个资源，`Semaphore`(信号量)可以指定多个线程同时访问某个资源。
- **`CountDownLatch `（倒计时器）：** `CountDownLatch` 是一个同步工具类，用来协调多个线程之间的同步。这个工具通常用来控制线程等待，它可以让某一个线程等待直到倒计时结束，再开始执行。
- **`CyclicBarrier`(循环栅栏)：** `CyclicBarrier` 和 `CountDownLatch` 非常类似，它也可以实现线程间的技术等待，但是它的功能比 `CountDownLatch` 更加复杂和强大。主要应用场景和 `CountDownLatch` 类似。`CyclicBarrier` 的字面意思是可循环使用（`Cyclic`）的屏障（`Barrier`）。它要做的事情是，让一组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续干活。`CyclicBarrier` 默认的构造方法是 `CyclicBarrier(int parties)`，其参数表示屏障拦截的线程数量，每个线程调用 `await()` 方法告诉 `CyclicBarrier` 我已经到达了屏障，然后当前线程被阻塞。

### ConcurrentHashMap

* Java7 中 ConcurrentHashMap 使用的分段锁，也就是每一个 Segment 上同时只有一个线程可以操作，每一个 Segment 都是一个类似 HashMap 数组的结构，它可以扩容，它的冲突会转化为链表。但是 Segment 的个数一但初始化就不能改变。
* Java8 中的 ConcurrentHashMap 使用的 Synchronized 锁加 CAS 的机制。结构也由 Java7 中的 **Segment 数组 + HashEntry 数组 + 链表** 进化成了 **Node 数组 + 链表 / 红黑树**，Node 是类似于一个 HashEntry 的结构。它的冲突再达到一定大小时会转化成红黑树，在冲突小于一定数量时又退回链表。
* `synchronized` 只锁定当前链表或红黑二叉树的首节点，这样只要 hash 不冲突，就不会产生并发，效率又提升 N 倍。

## 框架

### Spring,Spring MVC,Spring Boot 之间的关系

* Spring 包含了多个功能模块（上面刚刚提高过），其中最重要的是 Spring-Core（主要提供 IoC 依赖注入功能的支持） 模块， Spring 中的其他模块（比如 Spring MVC）的功能实现基本都需要依赖于该模块。
* Spring MVC 是 Spring 中的一个很重要的模块，主要赋予 Spring 快速构建 MVC 架构的 Web 程序的能力。MVC 是模型(Model)、视图(View)、控制器(Controller)的简写，其核心思想是通过将业务逻辑、数据、显示分离来组织代码。
* Spring Boot 只是简化了配置，如果你需要构建 MVC 架构的 Web 程序，你还是需要使用 Spring MVC 作为 MVC 框架，只是说 Spring Boot 帮你简化了 Spring MVC 的很多配置，真正做到开箱即用。

### Spring IOC & AOP

#### IOC

* **IoC（Inverse of Control:控制反转）** 是一种设计思想，而不是一个具体的技术实现。IoC 的思想就是将原本在程序中手动创建对象的控制权，交由 Spring 框架来管理。不过， IoC 并非 Spring 特有，在其他语言中也有应用。
* 将对象之间的相互依赖关系交给 IoC 容器来管理，并由 IoC 容器完成对象的注入。这样可以很大程度上简化应用的开发，把应用从复杂的依赖关系中解放出来。 IoC 容器就像是一个工厂一样，当我们需要创建一个对象的时候，只需要配置好配置文件/注解即可，完全不用考虑对象是如何被创建出来的。

#### AOP

* AOP 即面向切面编程，简单地说就是将代码中重复的部分抽取出来，在需要执行的时候使用动态代理技术，在不修改源码的基础上对方法进行增强。
* 常用场景包括权限认证、自动缓存、错误处理、日志、调试和事务等。

### SpringBoot 自动装配

SpringBoot 所有⾃动配置类都是在启动的时候进⾏扫描并加载，通过spring.factories可以找到⾃动配置类的路径，但是不是所有存在于spring,factories中的配置都进⾏加载，⽽是通过@ConditionalOnClass注解进⾏判断条件是否成⽴（只要导⼊相应的stater，条件就能成⽴），如果条件成⽴则加载配置类，否则不加载该配置类
自动装配过程：

* SpringBoot在启动的时候从类路径下的META-INF/spring.factories中获取EnableAutoConfiguration指定的值
* 将这些值作为⾃动配置类导⼊容器 ，⾃动配置类就⽣效 ，帮我们进⾏⾃动配置⼯作；以前我们需要⾃⼰配置的东西 ，⾃动配置类都帮我们解决了
* 整个J2EE的整体解决⽅案和⾃动配置都在springboot-autoconfigure的jar包中；
* 它将所有需要导⼊的组件以全类名的⽅式返回 ， 这些组件就会被添加到容器中 ；
* 它会给容器中导⼊⾮常多的⾃动配置类 （xxxAutoConfiguration）, 就是给容器中导⼊这个场景需要的所有组件 ，并配置好这些组件 ；

Spring Boot 通过`@EnableAutoConfiguration`开启自动装配，通过 SpringFactoriesLoader 最终加载`META-INF/spring.factories`中的自动配置类实现自动装配，自动配置类其实就是通过`@Conditional`按需加载的配置类，想要其生效必须引入`spring-boot-starter-xxx`包实现起步依赖

### 常用注解

* 我们一般使用 `@Autowired` 注解让 Spring 容器帮我们自动装配 bean。要想把类标识成可用于 `@Autowired` 注解自动装配的 bean 的类,可以采用以下注解实现：
  - `@Component` ：通用的注解，可标注任意类为 `Spring` 组件。如果一个 Bean 不知道属于哪个层，可以使用`@Component` 注解标注。
  - `@Repository` : 对应持久层即 Dao 层，主要用于数据库相关操作。
  - `@Service` : 对应服务层，主要涉及一些复杂的逻辑，需要用到 Dao 层。
  - `@Controller` : 对应 Spring MVC 控制层，主要用于接受用户请求并调用 Service 层返回数据给前端页面。
* `@RestController`注解是`@Controller`和`@ResponseBody`的合集,表示这是个控制器 bean,并且是将函数的返回值直接填入 HTTP 响应体中,是 REST 风格的控制器。单独使用 `@Controller` 不加 `@ResponseBody`的话一般是用在要返回一个视图的情况，这种情况属于比较传统的 Spring MVC 的应用，对应于前后端不分离的情况。`@Controller` +`@ResponseBody` 返回 JSON 或 XML 形式数据
* `@Scope`声明 Spring Bean 的作用域，**四种常见的 Spring Bean 的作用域：**
  - singleton : 唯一 bean 实例，Spring 中的 bean 默认都是单例的。
  - prototype : 每次请求都会创建一个新的 bean 实例。
  - request : 每一次 HTTP 请求都会产生一个新的 bean，该 bean 仅在当前 HTTP request 内有效。
  - session : 每一个 HTTP Session 会产生一个新的 bean，该 bean 仅在当前 HTTP session 内有效。
* `@Configuration`声明配置类
* HTTP 请求类型
  * **GET** ：请求从服务器获取特定资源。举个例子：`GET /users`（获取所有学生）
  * **POST** ：在服务器上创建一个新的资源。举个例子：`POST /users`（创建学生）
  * **PUT** ：更新服务器上的资源（客户端提供更新后的整个资源）。举个例子：`PUT /users/12`（更新编号为 12 的学生）
  * **DELETE** ：从服务器删除特定的资源。举个例子：`DELETE /users/12`（删除编号为 12 的学生）
  * **PATCH** ：更新服务器上的资源（客户端提供更改的属性，可以看做作是部分更新），使用的比较少

## JavaWeb

### get、post、post 请求的区别

* GET 和 POST 是 HTTP 协议中的两种发送请求的方法。由于 HTTP 的底层是 TCP/IP。所以 GET 和 POST 的底层也是 TCP/IP 所以 GET 和 POST 在本质上没什么区别
* (两者之间最大的区别) GET 产生一个 TCP 数据包（浏览器会把 http header 和 data 一并发送出去，服务器响应 200（返回数据）)；POST产生两个TCP数据(浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据），但Firefox就只发送一次)。
* get 是从服务器上获取数据(查询数据)，post 是向服务器传送数据(数据添加、修改、删除)。
* Get把请求的数据放在url上面 即http的协议头上,post把数据放在http的包体内(requrest body)（post比get安全）。
* Get 请求参数通过 url 传递，所以传送的参数是有长度限制的，post 请求方法 在request body 中，所以没有限制(get、post理论上是都没有长度限制的,get提交的数据最大是2k,限制实际上是取决于浏览器;post 实际上有限制 IIS4最大量为80KB,IIS5为100KB)。
* Get 在浏览器回退时是无害的，而 post 会再次请求提交 。
* Get 请求会被浏览器主动 cache，而 post 不会 除非手动设置。
* Get 请求只能进行 url 编码(ASCII字符)，而 post 支持多种编码方式
* post那么好为什么还用get ? get效率高!

### Cookie 和 Session



## JVM

### JVM 内存结构

#### 程序计数器

* 内部保存 JVM 中下一条所要执行的指令的**地址**
* 作用：
  * 字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。
  * 在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。
* 特点：
  * 是线程私有的
  * **不会存在内存溢出**，是 JVM 规范中唯一一个不出现 OOM (内存溢出) 的区域，所以这个空间不会进行 GC (垃圾回收)

#### 虚拟机栈

* 虚拟机栈的生命周期和线程相同，随着线程的创建而创建，随着线程的死亡而死亡，方法调用的数据需要通过栈进行传递，每一次方法调用都会有一个对应的栈帧被压入栈中，每一个方法调用结束后，都会有一个栈帧被弹出。
* 每个栈由多个栈帧组成，对应着每次方法调用时所占用的内存，每个栈帧中存储着：
  * 局部变量表：存储方法里的 Java 基本数据类型以及对象的引用
  * 动态链接：也叫指向运行时常量池的方法引用
  * 方法返回地址：方法正常退出或者异常退出的定义
  * 操作数栈或表达式栈和其他一些附加信息
* 特点：
  * 是线程私有的
  * 栈内存**不需要进行GC**，方法开始执行的时候会进栈，方法调用后自动弹栈，相当于清空了数据
  * 栈内存分配越大，可用的线程数越少（内存越大，每个线程拥有的内存越大）

#### 堆

是 JVM 内存中最大的一块，通过 new 关键字**创建的对象**都会被放在堆内存，由所有线程共享，由**垃圾回收器**管理的主要区域，堆中对象大部分都需要考虑线程安全的问题

#### 本地方法栈

* 本地方法栈是为虚拟机执行本地方法时提供服务的
* 本地方法被执行的时候，在本地方法栈也会创建一个栈帧
* 特点：
  * 是线程私有的

#### 方法区

* JVM 运行时数据区域的一块逻辑区域，是各个线程共享的内存区域，用于存储已被虚拟机加载的类信息、常量、即时编译器编译后的代码等数据。
* 方法区是一个 JVM 规范，**永久代**( jdk1.8 以前)**与元空间**( jdk1.8 以后)都是其一种实现方式。
* 为了**避免方法区出现 OOM**，在 JDK8 中将堆内的方法区（永久代）移动到了本地内存上，重新开辟了一块空间，叫做元空间，元空间存储类的元信息，**静态变量和字符串常量池等放入堆中**。

#### 直接内存

* 直接内存是 Java 堆外、直接向系统申请的内存区间，不是虚拟机运行时数据区的一部分

### 对象创建的过程

1. 类加载检查

   虚拟机遇到一条 new 指令时，首先将去检查这个指令的参数是否能在常量池中定位到这个类的符号引用，并且检查这个符号引用代表的类是否已被加载过、解析和初始化过。如果没有，那必须先执行相应的类加载过程。

2. 分配内存

   在**类加载检查**通过后，接下来虚拟机将为新生对象**分配内存**。对象所需的内存大小在类加载完成后便可确定，为对象分配空间的任务等同于把一块确定大小的内存从 Java 堆中划分出来。

3. 初始化零值

   内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头），这一步操作保证了对象的实例字段在 Java 代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。

4. 设置对象头

   初始化零值完成之后，**虚拟机要对对象进行必要的设置**，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的 GC 分代年龄等信息。 **这些信息存放在对象头中。** 另外，根据虚拟机当前运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。

5. 执行init方法

   在上面工作都完成之后，从虚拟机的视角来看，一个新的对象已经产生了，但从 Java 程序的视角来看，对象创建才刚开始，`<init>` 方法还没有执行，所有的字段都还为零。所以一般来说，执行 new 指令之后会接着执行 `<init>` 方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来。

### JVM 垃圾回收

#### 判断对象是否可以回收

##### 引用计数法

* 给对象中添加一个引用计数器，每当有一个地方引用它，计数器就加 1；当引用失效，计数器就减 1；任何时候计数器为 0 的对象就是不可能再被使用的
* 缺点：无法解决循环引用问题，会引发内存泄露

##### 可达性分析算法

* 通过一系列的称为 **“GC Roots”** 的对象作为起点，从这些节点开始向下搜索，节点所走过的路径称为引用链，当一个对象到 GC Roots 没有任何引用链相连的话，则证明此对象是不可用的，需要被回收。
* **GC Roots 对象：**
  - 虚拟机栈中局部变量表中引用的对象：各个线程被调用的方法中使用到的参数、局部变量等
  - 本地方法栈中引用的对象
  - 堆中类静态属性引用的对象
  - 方法区中的常量引用的对象
  - 字符串常量池（string Table）里的引用
  - 同步锁 synchronized 持有的对象

##### 引用分析

1. 强引用：
2. 软引用：
3. 弱引用：
4. 虚引用：
5. 终结器引用：

#### 垃圾收集算法

#### 垃圾收集器

### 类加载机制

## 设计模式

### 代理模式

使用代理对象来代替对真实对象的访问，这样就可以在不修改原目标对象的前提下，提供额外的功能操作，扩展目标对象的功能。代理模式主要作用是扩展目标对象的功能，比如说在目标对象的某个方法执行前后你可以增加一些自定义的操作。

#### 静态代理

#### 动态代理

### 单例模式

在我们的系统中，有一些对象其实我们只需要一个，比如说：线程池、缓存、对话框、注册表、日志对象、充当打印机、显卡等设备驱动程序的对象。事实上，这一类对象只能有一个实例，如果制造出多个实例就可能会导致一些问题的产生，比如：程序的行为异常、资源使用过量、或者不一致性的结果。

**使用单例模式的好处:**

- 对于频繁使用的对象，可以省略创建对象所花费的时间，这对于那些重量级对象而言，是非常可观的一笔系统开销；
- 由于 new 操作的次数减少，因而对系统内存的使用频率也会降低，这将减轻 GC 压力，缩短 GC 停顿时间。

# 计算机网络



# MySQL

# Redis