# 三水点评项目总结

## 一. 短信登陆模块

* 初始基于 cookie 以及 session 来实现短信验证登录以及注册功能，利用拦截器完成登录校验（刷新 token 有效期）的功能，这样就不必在每个 Controller 中再单独实现校验功能了。
* 使用 UserDTO 类来隐藏用户的敏感信息，**同时为了保证登陆验证信息只保存在用户当前线程中，以免产生多线程并发修改登陆验证信息的安全问题**，所以基于 ThreadLocal 创建 UserHolder 类。
* session 会出现共享问题：多台 Tomcat 并不共享 session 存储空间，当请求切换到不同 tomcat 服务时导致数据丢失的问题。Tomcat 会有数据拷贝功能，但十分浪费性能及内存空间，因此使用 Redis 来代替 session，以随机 token 为 key 存储用户数据。
* **优化拦截器：原先拦截器只拦截需要登陆校验的路径，导致用户如果一直访问的是不需要登录的页面，拦截器就不会生效，也就不会刷新 token 有效期，因此没过多久用户的登陆凭证就会失效，因此在原有的基础上再添加一个拦截器，第一个拦截器保证用户的一切请求都会刷新 token 有效期，第二个拦截器只来查询 ThreadLocal 中是否存在用户，即拦截。**

## 二. 商家查询缓存模块

* 给商户查询模块添加缓存，加速查询，应用读取数据时，需要先读取 Redis，若未命中，发生缓存缺失，则去数据库读取数据，同时还需要更新缓存，保持与数据库一致。
  * Redis 缓存补充：
    * 缓存的两大特征：访问速度要快，有数据淘汰策略，Redis 天然具有**高性能访问**（在内存上，IO 复用）和**数据淘汰机制**（LRU、LFU）
      * Redis 的高性能访问：
        * Redis 的大部分操作在内存上完成，再加上它采用了高效的数据结构，例如哈希表和跳表
        * Redis 采用了**多路复用机制**，使其在网络 IO 操作中能并发处理大量的客户端请求，实现高吞吐率
      * Redis 缓存的淘汰策略：
        * LRU（时间戳）更加关注数据的时效性，LFU（时间戳 + 访问频次）更加关注数据的访问频次
        * ![img](https://static001.geekbang.org/resource/image/04/f6/04bdd13b760016ec3b30f4b02e133df6.jpg)
    * Redis 作为缓存的两种形式：只读缓存（先改数据库再删缓存，能保持完全一致）和读写缓存（同时修改数据库和缓存中的数据，可能会导致不一致的情况，异步写回和同步直写）
* 缓存更新策略：
  * 低一致性需求：使用内存淘汰机制。例如店铺类型的查询缓存
  * 高一致性需求：主动更新，并以超时剔除（给缓存数据添加 TTL 过期时间，到期后自动删除缓存，下次查询时更新缓存）作为兜底方案。例如店铺详情查询的缓存
    * 直接删除缓存，而不是更新缓存，因为每次更新数据库都更新缓存，无效写操作比较多
    * 保证缓存与数据库操作的原子性 **使用 @Transactional 注解**
    * 先操作数据库，再删除缓存
      * ![img](https://static001.geekbang.org/resource/image/11/6f/11ae5e620c63de76448bc658fe6a496f.jpg)
      * 先删除缓存值再更新数据库，有可能导致请求因缓存缺失而访问数据库，给数据库带来压力；
      * 如果业务应用中读取数据库和写缓存的时间不好估算，那么，延迟双删中的等待时间就不好设置
  * 读写缓存：采用同步直写策略，使用事务，保证缓存和数据库的更新具有原子性，一致性不高的场景，使用异步写回策略
* 封装缓存 Redis 的工具类：
  * 缓存穿透：客户端请求的数据在缓存中和数据库中都不存在，这样缓存永远不会生效，这些请求都会打到数据库，如果应用持续有大量请求访问数据，就会同时给缓存和数据库带来巨大压力
    * 缓存空对象：会有额外的内存消耗，可能造成短期的不一致，可以设置 TTL 过期时间
    * 布隆过滤：在客户端与 Redis 之间设置一层布隆过滤器，不是 100% 准确，但内存占用小
      * 布隆过滤器由一个初值都为 0 的 bit 数组和 N 个哈希函数组成，可以用来快速判断某个数据是否存在
      * 布隆过滤器是一个包含 10 个 bit 位的数组，使用了 3 个哈希函数，当在布隆过滤器中标记数据 X 时，X 会被计算 3 次哈希值，并对 10 取模，取模结果分别是 1、3、7。所以，bit 数组的第 1、3、7 位被设置为 1。当应用想要查询 X 时，只要查看数组的第 1、3、7 位是否为 1，只要有一个为 0，那么，X 就肯定不在数据库中
    * 在请求入口的前端进行请求检测：缓存穿透的一个原因是有大量的恶意请求访问不存在的数据，所以，一个有效的应对方案是在请求入口前端，对业务系统接收到的请求进行合法性检测
  * 缓存雪崩：在同一时段大量的缓存 key 同时失效或者 Redis 服务宕机，导致大量请求到达数据库，带来巨大压力
    * 给不同的 Key 的 TTL 添加随机值，避免同一时段大量的缓存 key 同时失效
    * 服务降级，指发生缓存雪崩时，针对不同的数据采取不同的处理方式
      * 当业务应用访问的是非核心数据（例如电商商品属性）时，暂时停止从缓存中查询这些数据，而是直接返回预定义信息、空值或是错误信息
      * 当业务应用访问的是核心数据（例如电商商品库存）时，仍然允许查询缓存，如果缓存缺失，也可以继续通过数据库读取。
    * 宕机时，采用服务熔断（事后），通过主从节点的方式构建 Redis 缓存高可靠集群（事前）
  * 缓存击穿：也叫热点 Key 问题，就是一个被**高并发访问**并且**缓存重建业务较复杂**的 Key 突然失效了，无数的请求访问会在瞬间给数据库带来巨大的冲击
    * 互斥锁：线程需要等待，性能会受影响，并且会产生两个线程互相等待的死锁情况
    * 逻辑过期：不设置 TTL 过期时间，只设置一个逻辑过期时间，但其不能保证一致性，并且有额外的内存消耗 

## 三. 优惠券秒杀模块

* 利用 Redis 生成全局唯一 ID （其他方法：UUID 数据库 snowflake（雪花算法））
  * 在复杂分布式系统中，往往需要对大量的数据和消息进行唯一标识，所以要生成全局唯一ID，如本项目中的优惠券订单ID
    * 唯一性：Redis 独立于数据库之外
    * 高可用：集群 主从 哨兵
    * 高性能：Redis 在内存上 多路复用机制
    * 安全性：为了增加 ID 的安全性，我们可以不直接使用Redis自增的数值，而是拼接一些其它信息：符号位 + 时间戳 + 序列号 
    * 递增性：Redis 也采用自增方案
  * 每天一个key，方便统计每天、每月、每年的订单量
* 秒杀券下单时需要判断两点：
  * 秒杀是否开始或结束，如果尚未开始或已经结束则无法下单
  * 库存是否充足，不足则无法下单
* **秒杀券库存超卖问题**
  * 线程安全问题，加锁，分为乐观锁和悲观锁
  * 悲观锁：认为线程安全问题一定会发生，因此在操作数据之前先获取锁，确保线程串行执行。例如Synchronized、Lock。
    * 优点：简单粗暴
    * 缺点：性能一般
  * 乐观锁：认为线程安全问题不一定会发生，因此不加锁，只是在更新数据时去判断有没有其它线程对数据做了修改（CAS法），即**判断 stock 是否大于 0**，如果没有修改则认为是安全的，自己才更新数据。如果已经被其它线程修改说明发生了安全问题，此时可以重试或异常。
    * 优点：性能好
    * 缺点：存在成功率低的问题，可以使用分段锁来解决
* 一人一单，要求用一个优惠券，一个用户只能下一单，判断订单是否存在来判断用户是否下过单
  * 使用悲观锁解决一人一单的问题，synchronized，锁对象为用户 id，来减少锁定用户的范围，从而一定程度上提高了性能。
  * 在单机情况下 synchronized 锁没问题，但放在集群模式下就会出现问题，在不同台服务器上，各自的 JVM 是不一样的，有各自的锁监视器，所以需要 Redis **分布式锁**来解决分布式情况下的一人一单问题
  * 分布式锁：可以使不同的 JVM 都能获得这个锁监视器，满足分布式系统或集群模式下多进程可见并且互斥的锁
    * ![image-20220419202923751](C:\Users\BaoShaWang\AppData\Roaming\Typora\typora-user-images\image-20220419202923751.png)
    * 多进程可见
    * 互斥
    * 高可用
    * 高性能
    * 安全性
    * **基于 Redis 实现分布式锁**：
      * 利用 Redis 的 **SETNX 命令（在执行时会判断键值对是否存在，如果不存在，就设置键值对的值，如果存在，就不做任何设置）**获取锁 ，DEL 命令释放锁，但这样会存在两个风险：
        * 一个客户端获取锁后发生异常不能释放锁，导致其他客户端无法拿到锁：**给锁变量设置一个过期时间**
        * 客户端 A 获取的锁被 B 释放了：**加锁操作时，让每个客户端给锁变量设置一个唯一的值**（可以用 UUID 表示）
        * 由于在释放锁的操作逻辑中包含了读取锁变量、判断值、删除锁变量的多个操作，所以**需要使用 Lua 脚本，从而保证释放锁操作的原子性**
        * 还存在的问题：![image-20220419211115979](C:\Users\BaoShaWang\AppData\Roaming\Typora\typora-user-images\image-20220419211115979.png)
      * Redisson 可重入锁原理：使用哈希结构，记录线程 id 和重入次数，获取锁次数+1，释放锁时次数-1，当重入次数为0时，删除这个锁
      * Redisson 可重试锁原理：利用信号量和 PubSub 消息传递模型实现等待、唤醒（另一个客户端释放锁时发送释放锁信号），获取锁失败（等待超过一定时间）的重试机制
      * Redisson 超时续约原理：利用 watchDog，开启一个定时任务，每隔一段时间（releaseTime / 3），重置超时时间
      * Redisson 主从一致性原理：利用 multiLock，让客户端和多个独立的 Redis 实例依次请求加锁，如果都能成功完成加锁工作，则客户端成功获取分布式锁
* 秒杀的业务流程：查询优惠券 → 判断秒杀库存 → 查询订单 → 校验一人一单 → 减库存 → 创建订单
  * 将订单信息和优惠券信息缓存到 Redis 中，把对于秒杀资格的判断放到 Redis 中去做
    * 使用 Redis 的 Set 集合来保存用户 Id
    * 使用 lua 脚本来保证这系列操作的原子性
  * 将记录的信息放到一个队列中，异步开启一个独立的线程取读取队列中的信息进行数据库的查询订单、减库存、创建订单耗时较久的操作
  * ![image-20220420110945245](C:\Users\BaoShaWang\AppData\Roaming\Typora\typora-user-images\image-20220420110945245.png)
  * 基于 JVM 的阻塞队列（ArrayBlockingQueue）来实现异步秒杀的问题：内存有限制，内存没有持久化，会出现安全问题
  * 基于 Redis 的消息队列来实现异步秒杀：
    * 消息队列：生产者发送消息，消息队列缓存这些消息，消费者异步从消息队列中读取这些消息，消息队列要满足三个需求：消息保序、处理重复的消息、保证消息可靠性
    * 基于 List 的消息队列
      * 优点：利用 Redis 存储，不受限于 JVM 内存上限，基于 Redis 的持久化机制，数据安全性有保证，List 本身按先进先出的顺序对数据进行存取，可以满足消息有序性
      * 缺点：当需要启动多个消费者程序组成消费组来分担处理 List 中的消息，但 List 不支持消费组的实现，只支持单消费者
    * 基于 Streams 的消息队列
      * XADD：插入消息，保证有序，可以自动生成全局唯一 ID
      * XREADGROUP：按消费组形式读取数据
      * 为了保证消费者在发生故障或宕机再次重启后，仍然可以读取未处理完的消息，Streams 会自动使用内部队列（也称为 PENDING List）留存消费组里每个消费者读取的消息，直到消费者使用 XACK 命令通知 Streams “消息已经处理完成”。如果消费者没有成功处理消息，就不会给 Streams 发送 XACK 命令，消息仍然会留存。此时，消费者可以在重启后，用 XPENDING 命令查看已读取、但尚未确认处理完成的消息
  * 作为消息队列，Redis 是一个非常轻量级的键值数据库，而 Kafka、RabbitMQ 部署时，涉及额外的组件，所以相比 Redis 来说，Kafka 和 RabbitMQ 一般被认为是重量级的消息队列，如果分布式系统中的组件消息通信量不大，那么，Redis 只需要使用有限的内存空间就能满足消息存储的需求，而且，Redis 的高性能特性能支持快速的消息读写，不失为消息队列的一个好的解决方案。
  * Redis 可以用作消息队列，而且性能很高，部署维护也很轻量，但缺点是无法严格保数据的完整性。而使用专业的队列中间件，可以严格保证数据的完整性，但缺点是，部署维护成本高，用起来比较重。

## 四. 达人探店点赞及点赞排行设计

* 完成发布以及查看探店笔记的功能模块	增删改查

* 点赞功能模块

  * 同一个用户只能点赞一次，再次点击则取消点赞

  * 如果当前用户已经点赞，则点赞按钮高亮显示（前端已实现，判断字段 Blog 类的 isLike 属性）

  * ① 给 Blog 类中添加一个 isLike 字段，标示是否被当前用户点赞

    ② 修改点赞功能，利用 Redis 的 SET 集合的键值的**唯一性**，判断是否点赞过，未点赞过则点赞数+1，已点赞过则点赞数 -1

    ③ 修改根据 id 查询 Blog 的业务，判断当前登录用户是否点赞过，赋值给 isLike 字段

    ④ 修改分页查询 Blog 业务，判断当前登录用户是否点赞过，赋值给 isLike 字段

* 点赞排行模块

  * 在探店笔记的详情页面，应该把给该笔记点赞的人显示出来，比如最早点赞的 TOP5，形成点赞排行榜
  * 由于 SET 集合无法排序，故使用 SortedSet 集合，根据点赞时间先后顺序，返回 TOP5 的用户

## 五. 好友关注模块

* 关注以及取关
  * 根据 tb_follow 表实现两个接口：关注和取关接口，判断是否关注的接口
* 共同关注
  * 利用 Redis 中的 SET 集合的取交集 SINTER 命令，取出两个用户的共同关注的用户集合，在博主个人页面展示出当前用户与博主的共同好友
* 关注推送：也叫做 Feed 流，直译为投喂。为用户持续的提供“沉浸式”的体验，通过无限下拉刷新获取新的信息。
  * Timeline：不做内容筛选，简单的按照内容发布时间排序，常用于好友或关注。例如朋友圈
  
    * 优点：信息全面，不会有缺失，并且实现也相对简单
    * 缺点：信息噪音较多，用户不一定感兴趣，内容获取效率低
  
  * 智能排序：利用智能算法屏蔽掉违规的、用户不感兴趣的内容。推送用户感兴趣信息来吸引用户
  
    * 优点：投喂用户感兴趣信息，用户粘度很高，容易沉迷
    * 缺点：如果算法不精准，可能起到反作用
  
  * 本项目中的个人页面，是基于关注的好友来做 Feed 流，因此采用 Timeline 的模式：① 拉模式(读扩散) ② **推模式 (写扩散) **不会有查询的压力 √ ③ 推拉结合
  
  * ① 修改新增探店笔记的业务，在保存 blog 到数据库的同时，推送到粉丝的收件箱
  
    ② 收件箱满足可以根据时间戳排序，必须用 Redis 的数据结构实现
  
    ③ 查询收件箱数据时，可以实现分页查询
  
  * Feed 流的分页问题 排序统计 实现滚动翻页（**项目难点**）
  
    * 使用 List 在涉及到分页操作时会出现问题，List 是通过元素在 List 中的位置来排序的，当有一个新元素插入时，原先的元素在 List 中的位置都后移了一位，比如说原来在第 1 位的元素现在排在了第 2 位。所以，对比新元素插入前后，List 相同位置上的元素就会发生变化，用 LRANGE 读取时，就会读到旧元素
    * 使用 Sorted Set 就不存在这个问题，因为它是根据元素的实际权重来排序和获取数据的，所以在面对需要展示最新列表、排行榜等场景时，如果数据更新频繁或者需要分页显示，优先考虑使用 Sorted Set

## 六. 查询附近商户模块

* 利用 Redis 的 GEO 数据结构完成查询附近商户模块的功能
  * GEO 底层用 Sorted Set 实现，元素是车辆 ID， 权重 Score 是经纬度信息
  * 经纬度通过 GeoHash 编码方式，对经度和纬度分别编码，然后组合成一个最终编码
    * 利用二分区间的方式，分在左区间用0表示，右区间用1表示，这样将一组经纬度转换成一个二进制的值
  * 利用 GEOSEARCH，在指定范围内搜索，并按照与指定点之间的距离排序后返回
  * GEOADD 命令：用于把一组经纬度信息和相对应的一个 ID 记录到 GEO 类型集合中
  * GEORADIUS 命令：会根据输入的经纬度位置，查找以这个经纬度为中心的一定范围内的其他元素。当然，我们可以自己定义这个范围
  * 可以使用 ASC 选项，让返回的车辆信息按照距离这个中心位置从近到远的方式来排序，以方便选择最近的车辆；还可以使用 COUNT 选项，指定返回的车辆信息的数量

## 七. 用户签到模块

* 用户签到信息表的结构![image-20220420200449074](C:\Users\BaoShaWang\AppData\Roaming\Typora\typora-user-images\image-20220420200449074.png)
* 在签到打卡场景中，我们只用记录签到（1）或未签到（0），在签到统计时，每个用户一天的签到用 1 个 bit 位就能表示，一个月（假设是 31 天）的签到情况用 31 个 bit 位就可以，而一年的签到也只需要用 365 个 bit 位，根本不用太复杂的集合类型。这个时候，我们就可以选择 **Bitmap**。
* Bitmap 本身是用 String 类型作为底层数据结构实现的一种统计二值状态的数据类型。String 类型是会保存为二进制的字节数组，所以，Redis 就把字节数组的每个 bit 位利用起来，用来表示一个元素的二值状态。你可以把 Bitmap 看作是一个 bit 数组。
* 利用 Bitmap 数据结构统计用户签到次数
  * 使用 SETBIT 命令记录签到，GETBIT 检查是否签到，BITCOUNT 统计签到次数
  * 在统计 1 亿个用户连续 10 天的签到情况时，你可以把每天的日期作为 key，每个 key 对应一个 1 亿位的 Bitmap，每一个 bit 对应一个用户当天的签到情况。接下来，我们对 10 个 Bitmap 做“与”操作，得到的结果也是一个 Bitmap。在这个 Bitmap 中，只有 10 天都签到的用户对应的 bit 位上的值才会是 1。最后，我们可以用 BITCOUNT 统计下 Bitmap 中的 1 的个数，这就是连续签到 10 天的用户总数了。
* 只需要统计数据的二值状态，例如商品有没有、用户在不在等，就可以使用 Bitmap

## 八. UV统计模块

UV：全称 Unique Visitor，也叫独立访客量，是指通过互联网访问、浏览这个网页的自然人。1 天内同一个用户多次访问该网站，只记录1次
PV：全称 Page View，也叫页面访问量或点击量，用户每访问网站的一个页面，记录 1 次 PV，用户多次打开页面，则记录多次 PV，往往用来衡量网站的流量

* UV 统计在服务端做会比较麻烦，因为要判断该用户是否已经统计过了，需要将统计过的用户信息保存。但是如果每个访问的用户都保存到 Redis 中，数据量会非常恐怖，为了去重，如果使用 SET 集合的话为消耗很大的内存空间。因此，使用 HyperLogLog，一种用于统计基数的数据集合类型，它的最大优势就在于，当集合元素数量非常多时，它计算基数所需的空间总是固定的，而且还很小
* HyperLogLog 的统计规则是基于概率完成的，所以它给出的统计结果是有一定误差的，标准误算率是 0.81%

## 九. 其他细节

* Redis 的序列化方式：

  * JdkSerializationRedisSerializer 默认序列化方式
    * 优点：
      * 反序列化时不需要提供类型信息(class)

    * 缺点：
      * 需要实现Serializable接口
      * 存储的为二进制数据
      * 序列化后的结果非常庞大，是JSON格式的5倍左右，这样就会消耗redis服务器的大量内存
  * Jackson2JsonRedisSerializer

    * 优点：
      * 速度快，序列化后的字符串短小精悍，不需要实现 Serializable 接口

    * 缺点：
      * 此类的构造函数中有一个类型参数，必须提供要序列化对象的类型信息( .class 对象），其在反序列化过程中用到了类型信息
  * 使用 StringRedisTemplate 默认的 StringRedisSerializer 序列化方式，当存储对象时需要手动序列化和反序列化（使用 fastJson 或者 SpringMVC 默认提供的 Object Mapper Json 处理工具）
* 单点登录
* full gc
* cpu 飙升

## 十. 项目难点

### feed 流的分页问题

* Feed 流的分页问题 排序统计 实现滚动翻页（**项目难点**）

  * 使用 List 在涉及到分页操作时会出现问题，List 是通过元素在 List 中的位置来排序的，当有一个新元素插入时，原先的元素在 List 中的位置都后移了一位，比如说原来在第 1 位的元素现在排在了第 2 位。所以，对比新元素插入前后，List 相同位置上的元素就会发生变化，用 LRANGE 读取时，就会读到旧元素
  * 使用 Sorted Set 就不存在这个问题，因为它是根据元素的实际权重来排序和获取数据的，所以在面对需要展示最新列表、排行榜等场景时，如果数据更新频繁或者需要分页显示，优先考虑使用 Sorted Set

### Redis 缓存数据与数据库如何保持一致

缓存更新策略：

* 低一致性需求：使用内存淘汰机制。例如店铺类型的查询缓存
* 高一致性需求：主动更新，并以超时剔除（给缓存数据添加 TTL 过期时间，到期后自动删除缓存，下次查询时更新缓存）作为兜底方案。例如店铺详情查询的缓存
  * 直接删除缓存，而不是更新缓存，因为每次更新数据库都更新缓存，无效写操作比较多
  * 保证缓存与数据库操作的原子性 **使用 @Transactional 注解**
  * 先操作数据库，再删除缓存
    * ![img](https://static001.geekbang.org/resource/image/11/6f/11ae5e620c63de76448bc658fe6a496f.jpg)
    * 先删除缓存值再更新数据库，有可能导致请求因缓存缺失而访问数据库，给数据库带来压力；
    * 如果业务应用中读取数据库和写缓存的时间不好估算，那么，延迟双删中的等待时间就不好设置
* 读写缓存：采用同步直写策略，使用事务，保证缓存和数据库的更新具有原子性，一致性不高的场景，使用异步写回策略

### 分布式锁

* 基于 Redis 实现分布式锁：
  * 利用 Redis 的 **SETNX 命令（在执行时会判断键值对是否存在，如果不存在，就设置键值对的值，如果存在，就不做任何设置，键设置为锁）**获取锁 ，DEL 命令释放锁，但这样会存在两个风险：
    * 一个客户端获取锁后发生异常不能释放锁，导致其他客户端无法拿到锁：**给锁变量设置一个过期时间**
    * 客户端 A 获取的锁被 B 释放了：**加锁操作时，让每个客户端给锁变量设置一个唯一的值**（可以用 UUID 表示）
    * 由于在释放锁的操作逻辑中包含了读取锁变量、判断值、删除锁变量的多个操作，所以**需要使用 Lua 脚本，从而保证释放锁操作的原子性**
    * 还存在的问题：![image-20220419211115979](C:\Users\BaoShaWang\AppData\Roaming\Typora\typora-user-images\image-20220419211115979.png)
  * Redisson 可重入锁原理：使用哈希结构，记录线程 id 和重入次数，获取锁次数+1，释放锁时次数-1，当重入次数为0时，删除这个锁
  * Redisson 可重试锁原理：利用信号量和 PubSub 消息传递模型实现等待、唤醒（另一个客户端释放锁时发送释放锁信号），获取锁失败（等待超过一定时间）的重试机制
  * Redisson 超时续约原理：利用 watchDog，开启一个定时任务，每隔一段时间（releaseTime / 3），重置超时时间
  * Redisson 主从一致性原理：利用 multiLock，让客户端和多个独立的 Redis 实例依次请求加锁，如果都能成功完成加锁工作，则客户端成功获取分布式锁

### 优化拦截器

原先拦截器只拦截需要登陆校验的路径，导致用户如果一直访问的是不需要登录的页面，拦截器就不会生效，也就不会刷新 token 有效期，因此没过多久用户的登陆凭证就会失效，因此在原有的基础上再添加一个拦截器，**第一个拦截器保证用户的一切请求都会刷新 token 有效期，第二个拦截器只来查询 ThreadLocal 中是否存在用户，即拦截**。

## 十一. OOM 定位和解决

### OOM 产生的原因

* 一次性申请的对象太多
* 内存资源耗尽未释放
* 本身资源内存不够
  * jmap -heap 查看堆内存信息

### 解决方法

* 利用 jmap 命令生成堆转储快照，即 dump 文件，jmap -dump:format=b,file=..... pid
* 利用 mat 工具分析 dump 文件，就可以看到内存占用率高的线程

## 十二. 优化效果

# 三水论坛项目总结

# 三水聊天室项目总结



# 三水 RPC 项目总结

## RPC 处理流程

1. 客户端建立连接并发送一个请求消息至服务器端

   ```java
   Channel channel = bootstrap.connect("localhost", 8080).sync().channel();
   channel.writeAndFlush(rpcRequestMessage);
   ```

2. 客户端的 **出站 **处理器 **从下至上 **依次执行

   ```java
   bootstrap.handler(new ChannelInitializer<SocketChannel>() {
   	@Override
   	protected void initChannel(SocketChannel ch) throws Exception {
   		ch.pipeline().addLast(new ProtocolFrameDecoder());
   		ch.pipeline().addLast(LOGGING_HANDLER); // 出站处理器
   		ch.pipeline().addLast(MESSAGE_CODEC); // 出站处理器
   		ch.pipeline().addLast(RPC_HANDLER);
   	}
   });
   ```

3. 消息到达服务器端，**入站 **处理器 **从上至下 **依次执行

   ```java
   serverBootstrap.childHandler(new ChannelInitializer<SocketChannel>() {
       @Override
       protected void initChannel(SocketChannel ch) throws Exception {
           ch.pipeline().addLast(new ProtocolFrameDecoder()); // 入站处理器
           ch.pipeline().addLast(LOGGING_HANDLER); // 入站处理器
           ch.pipeline().addLast(MESSAGE_CODEC); // 入站处理器
           ch.pipeline().addLast(RPC_HANDLER); // 入站处理器
       }
   });
   ```

4. 消息至服务器端的 RPC_HANDLER 中，**根据消息信息得到接口，根据接口得到其实现对象，根据对象得到要调用的方法，利用反射进行调用**，将成功或者异常消息封装至响应消息中

   ```java
   RpcResponseMessage response = new RpcResponseMessage();
   try {
       // ServiceFactory.getService(interfaceClass) 根据接口类得到它的实现类
   	HelloService service = (HelloService) ServiceFactory.getService(Class.forName(msg.getInterFaceName()));
   	Method method = service.getClass().getMethod(msg.getMethodName(), msg.getParameterTypes());
   	Object invoke = method.invoke(service, msg.getParameterValue());
   	response.setReturnValue(invoke);
   } catch (ClassNotFoundException | NoSuchMethodException | SecurityException | IllegalAccessException |
   		IllegalArgumentException | InvocationTargetException e) {
   	e.printStackTrace();
   	response.setExceptionValue(e);
   }
   ctx.writeAndFlush(response);
   ```

5. 封装好的响应消息，经过服务器端的 **出站** 处理， **从下至上** 依次执行

   ```java
   serverBootstrap.childHandler(new ChannelInitializer<SocketChannel>() {
       @Override
       protected void initChannel(SocketChannel ch) throws Exception {
           ch.pipeline().addLast(new ProtocolFrameDecoder());
           ch.pipeline().addLast(LOGGING_HANDLER); // 出站处理器
           ch.pipeline().addLast(MESSAGE_CODEC); // 出站处理器
           ch.pipeline().addLast(RPC_HANDLER);
       }
   });
   ```

6. 消息发送至客户端，客户端进行 **入站 **处理，**从上至下 **依次执行

   ```java
   bootstrap.handler(new ChannelInitializer<SocketChannel>() {
   	@Override
   	protected void initChannel(SocketChannel ch) throws Exception {
   		ch.pipeline().addLast(new ProtocolFrameDecoder()); // 入站处理器
   		ch.pipeline().addLast(LOGGING_HANDLER); // 入站处理器
   		ch.pipeline().addLast(MESSAGE_CODEC); // 入站处理器
   		ch.pipeline().addLast(RPC_HANDLER); // 入站处理器
   	}
   });
   ```

7. 最后消息交给客户端的 RPC_HANDLER，将消息进行打印

   ```java
   log.debug("{}", msg);
   ```

## 遇到的问题与解决方法

* Gson
* 
